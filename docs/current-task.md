# Current Task: Phase 13 — Antivax Separate Swarm + Steering Fixes

Read CLAUDE.md for full project context. Read `.orchestrator/context.md` for the authoritative simulation specification (3-swarm model, Reynolds formulas, interaction matrix). Check `src/*/changelog.md` for recent changes.

## Requirements (implement ONE per session, in order)

- [ ] **A1: Component & Stats Infrastructure** — In `include/components.h`: (1) Add `struct AntivaxBoid {};` as a new primary swarm tag (document it as mutually exclusive with NormalBoid and DoctorBoid). Keep `struct Antivax {};` temporarily — it will be removed in A9. (2) Add to `SimStats`: `int antivax_alive = 0;`, `int dead_antivax = 0;`, `int newborns_antivax = 0;`. (3) Add to `PopulationHistoryPoint`: `int antivax_alive = 0;`. In `src/ecs/world.cpp`: register `AntivaxBoid` component with `world.component<AntivaxBoid>();`. Success: build clean, all 23 tests pass, no runtime changes. Commit: `feat(ecs): add AntivaxBoid primary tag and antivax stats fields`

- [ ] **A2: Spawn AntivaxBoid from Normal Pool** — In `src/ecs/spawn.cpp`, `spawn_normal_boids()`: change the antivax assignment block so that instead of adding the `Antivax` tag on top of `NormalBoid`, it replaces `NormalBoid` with `AntivaxBoid`. Specifically: if the `p_antivax` roll succeeds, the entity should have `AntivaxBoid` (NOT `NormalBoid`, NOT `Antivax`) — they are mutually exclusive. If roll fails, entity keeps `NormalBoid` as before. The easiest approach: create the entity without any swarm tag first, then conditionally add either `AntivaxBoid` or `NormalBoid`. Remove the old `boid.add<Antivax>()` line. Also in `reset_simulation()`: no changes needed — it already deletes all entities with `Position` component. Success: build clean, ~20 antivax boids spawned (10% of 200). Commit: `feat(ecs): spawn AntivaxBoid as separate swarm from normal pool`

- [ ] **A3: Render Antivax in Orange** — (1) In `include/render_state.h`, change `BoidRenderData`: replace `bool is_doctor` with `int swarm_type` where 0=normal, 1=doctor, 2=antivax. (2) In `src/render/render_config.h`: add `constexpr uint32_t COLOR_ANTIVAX = 0xFF00A5FF;` (orange in ABGR) and `constexpr uint32_t COLOR_RADIUS_ANTIVAX = 0x4000A5FF;` (semi-transparent orange). (3) In `src/ecs/systems.cpp`, `register_render_sync_system()`: update the render sync to set `brd.swarm_type` — check `AntivaxBoid` tag → 2, `DoctorBoid` tag → 1, else 0. For color assignment: infected gets COLOR_INFECTED, antivax gets COLOR_ANTIVAX, doctor gets COLOR_DOCTOR, normal gets COLOR_NORMAL. For radius, antivax uses `r_interact_normal`. (4) In `src/render/renderer.cpp`: update `render_frame()` and `draw_stats_overlay()` to use `swarm_type` instead of `is_doctor`. Radius color: swarm_type==1 → COLOR_RADIUS_DOCTOR, swarm_type==2 → COLOR_RADIUS_ANTIVAX, else COLOR_RADIUS_NORMAL. Success: three visually distinct boid colors visible. Commit: `feat(render): render antivax boids in distinct orange color`

- [ ] **A4: Antivax Infection (same-swarm only)** — In `src/ecs/systems.cpp`, `register_infection_system()`: add a third infection block for AntivaxBoid, AFTER the Doctor block but BEFORE `w.defer_end()`. Pattern: iterate `AntivaxBoid + Alive` entities, for each infected one query neighbors within `effective_r_interact` (= `config.r_interact_normal * config.debuff_r_interact_normal_infected`), only infect neighbors with `AntivaxBoid` tag (same-swarm), use `p_infect_normal` probability. Copy the NormalBoid infection block structure and change `NormalBoid` → `AntivaxBoid`. Also in `spawn.cpp`: AntivaxBoid entities already use `p_initial_infect_normal` for initial infection (set during spawn). Success: build clean, antivax boids can infect each other but not cross-swarm. Commit: `feat(sim): wire antivax-to-antivax infection (same-swarm only)`

- [ ] **A5: Antivax Reproduction (same-swarm, offspring inherit)** — In `src/ecs/systems.cpp`, `register_reproduction_system()`: add a third reproduction block for AntivaxBoid AFTER the Doctor block but BEFORE `w.defer_end()`. Copy the NormalBoid reproduction block structure. Key differences: (1) Query `AntivaxBoid + Alive` entities. (2) Only reproduce with other `AntivaxBoid` (same-swarm). (3) Use Normal reproduction parameters: `p_offspring_normal`, `offspring_mean_normal` (2.0), `offspring_stddev_normal` (1.0). (4) Apply debuff `debuff_p_offspring_normal_infected` when parent infected. (5) Sex system: require Male + Female pair. (6) Offspring are tagged `AntivaxBoid` (NOT NormalBoid — inherit parent swarm). (7) Increment `stats.newborns_antivax` and `stats.newborns_total`. Success: build clean, antivax population can grow through reproduction. Commit: `feat(sim): wire antivax reproduction (same-swarm, offspring inherit AntivaxBoid)`

- [ ] **A6: Verify Doctor Cures Antivax** — In `src/ecs/systems.cpp`, `register_cure_system()`: READ the code and verify that the cure system checks `ne.has<Infected>()` WITHOUT filtering to NormalBoid/DoctorBoid only. The current implementation already cures ANY infected neighbor — confirm this works for AntivaxBoid too. Also verify: doctors cannot cure THEMSELVES (check for `if (nid == e.id()) continue;`). Add a code comment above that line: `// Contract: doctors cannot cure themselves — only another doctor can cure them`. If the cure system DOES filter by swarm tag, add AntivaxBoid to accepted targets. Most likely NO code change needed — but MUST verify by reading. Success: infected antivax boids near a doctor can be cured, doctor self-cure does not happen. Commit: `feat(sim): verify and document doctor-cures-antivax + no-self-cure contract`

- [ ] **A7: Antivax Stats Tracking + Graph** — (1) In `src/ecs/stats.cpp`, `register_stats_system()`: add antivax_alive counter. Reset it at start of frame (`stats.antivax_alive = 0;`), then add a query: `auto q_antivax = w.query<const AntivaxBoid, const Alive>(); q_antivax.each([&stats](const AntivaxBoid&, const Alive&) { stats.antivax_alive++; });`. Include the antivax_alive in population history: `stats.history[stats.history_index].antivax_alive = stats.antivax_alive;`. (2) In `src/ecs/systems.cpp`, `register_death_system()`: add an `else if (e.has<AntivaxBoid>())` branch to increment `stats.dead_antivax`. (3) In `src/render/renderer.cpp`, `draw_stats_overlay()`: add labels for Antivax Alive, Dead Antivax, Newborns Antivax after the existing stats rows. (4) In `draw_population_graph()`: add an orange line for antivax_alive (Color{255, 165, 0, 255}). Update the total for max calculation to include antivax. Add legend entry. You may need to increase `panel_height` if the new rows don't fit. Success: stats panel shows antivax counts, graph has 3 lines. Commit: `feat(render): add antivax stats tracking and population graph line`

- [ ] **A8: Antivax Doctor-Avoidance Steering** — In `src/ecs/systems.cpp`, `register_antivax_steering_system()`: change the query from `<const Position, Velocity, const NormalBoid, const Antivax, const Alive>` to `<const Position, Velocity, const AntivaxBoid, const Alive>`. Remove `const NormalBoid&` and `const Antivax&` from the lambda parameters — replace with `const AntivaxBoid&`. The repulsion logic itself stays the same (uses `antivax_repulsion_radius` and `antivax_repulsion_weight`). Success: antivax boids visibly flee from nearby doctors. Commit: `feat(ecs): update antivax steering to use AntivaxBoid primary tag`

- [ ] **A9: Remove Deprecated Antivax Tag** — (1) In `include/components.h`: delete `struct Antivax {};`. (2) In `src/ecs/world.cpp`: delete `world.component<Antivax>();`. (3) Grep the ENTIRE codebase for any remaining references to `Antivax` that are NOT `AntivaxBoid` — remove them all. Use: search for `<Antivax>` and `Antivax` patterns. The only remaining references should be `AntivaxBoid`. (4) Build clean + all tests pass. Success: no references to the deprecated `Antivax` tag remain in codebase. Commit: `refactor(ecs): remove deprecated Antivax tag, migration to AntivaxBoid complete`

- [ ] **B1: Doctor No-Self-Cure Unit Test** — Create a new test file `tests/test_cure.cpp`. Write a FLECS-based test: (1) Create a flecs::world. (2) Register components (Position, Velocity, Heading, Health, InfectionState, ReproductionCooldown, DoctorBoid, Infected, Alive, Male, Female). (3) Set SimConfig singleton (defaults are fine). (4) Set SimStats singleton. (5) Create a SpatialGrid singleton with `SpatialGrid(1920, 1080, 40)`. (6) Create one DoctorBoid entity at position (500, 500) with Infected + InfectionState{0.0f, 5.0f} + Alive. (7) Register ONLY the rebuild_grid_system and cure_system. (8) Progress the world for several frames (e.g., 60 iterations of `world.progress(1.0f/60.0f)`). (9) Assert the doctor still has `Infected` tag — self-cure did not happen. (10) Add a SECOND healthy DoctorBoid at position (510, 510) within cure radius, progress again. (11) Assert the first doctor may now be cured (the Infected tag may be removed — this is probabilistic, so run enough frames or set p_cure=1.0). Add the test to `CMakeLists.txt` — look at how `test_spatial` and `test_config_loader` are added and follow the same pattern. Success: new test passes, all existing tests pass. Commit: `test(sim): add doctor no-self-cure contract test`

- [ ] **C1: Fix Cohesion Steering** — CRITICAL: ALL steering behaviors MUST use the Reynolds formula: `steering = (desired_velocity - current_velocity) * weight` where `desired_velocity = normalize(direction) * max_speed`. In `src/ecs/systems.cpp`, `register_steering_system()`, find the cohesion block (starts with `if (coh_count > 0)`). Replace the current `force_x += (coh_x - pos.x) * config.cohesion_weight;` pattern with the canonical form: `float dx = coh_x - pos.x; float dy = coh_y - pos.y; float mag = std::sqrt(dx*dx + dy*dy); if (mag > 0.001f) { float desired_vx = (dx/mag) * config.max_speed; float desired_vy = (dy/mag) * config.max_speed; force_x += (desired_vx - vel.vx) * config.cohesion_weight; force_y += (desired_vy - vel.vy) * config.cohesion_weight; }`. Do NOT change separation or alignment in this task. Success: build clean, all tests pass. Commit: `fix(ecs): correct cohesion to use normalized desired velocity (Reynolds steering)`

- [ ] **C2: Fix Alignment Steering** — CRITICAL: Alignment desired velocity = `normalize(avg_neighbor_vel) * max_speed`. In `src/ecs/systems.cpp`, `register_steering_system()`, find the alignment block (starts with `if (ali_count > 0)`). Replace the current `force_x += (ali_vx - vel.vx) * config.alignment_weight;` pattern with: `float ali_mag = std::sqrt(ali_vx*ali_vx + ali_vy*ali_vy); if (ali_mag > 0.001f) { float desired_vx = (ali_vx/ali_mag) * config.max_speed; float desired_vy = (ali_vy/ali_mag) * config.max_speed; force_x += (desired_vx - vel.vx) * config.alignment_weight; force_y += (desired_vy - vel.vy) * config.alignment_weight; }`. Do NOT change separation or cohesion in this task. Success: build clean, all tests pass. Commit: `fix(ecs): normalize alignment desired velocity to max_speed (Reynolds steering)`

- [ ] **C3: Swarm-Specific Flocking** — In `src/ecs/systems.cpp`, `register_steering_system()`: add a helper lambda or inline function `same_swarm` that checks if two entities share the same primary swarm tag: `auto same_swarm = [](flecs::entity a, flecs::entity b) -> bool { if (a.has<NormalBoid>() && b.has<NormalBoid>()) return true; if (a.has<DoctorBoid>() && b.has<DoctorBoid>()) return true; if (a.has<AntivaxBoid>() && b.has<AntivaxBoid>()) return true; return false; };`. In the neighbor loop: (1) Separation stays as-is — applies to ALL boids. (2) For alignment: only include neighbor if `same_swarm(e, ne)`. (3) For cohesion: only include neighbor if `same_swarm(e, ne)`. Success: three visually distinct flocks form and move independently. Commit: `feat(ecs): implement swarm-specific flocking (same-swarm alignment/cohesion)`

- [ ] **C4: Minimum Speed Enforcement** — (1) In `include/components.h`: add `float min_speed = 54.0f;` to SimConfig (30% of 180.0 max_speed). (2) In `config.ini`: add `min_speed = 54.0` under the `[movement]` section. (3) In `src/sim/config_loader.cpp`: add `else if (key == "min_speed") { config.min_speed = parse_float(val, line_num); }` in the movement section of `apply_field()`. (4) In `src/ecs/systems.cpp`, `register_steering_system()`: AFTER the max_speed clamping block at the end of the lambda, add minimum speed enforcement: `if (speed > 0.001f && speed < config.min_speed) { float scale = config.min_speed / speed; vel.vx *= scale; vel.vy *= scale; }`. Note: use the already-computed `speed` variable. Success: build clean, all tests pass, boids never stall. Commit: `feat(ecs): enforce minimum boid speed to prevent stalling`

## Guardrails
- Do NOT break existing simulation rules — read `.orchestrator/context.md` for the authoritative spec
- MUTUALLY EXCLUSIVE swarm tags: an entity is NormalBoid OR DoctorBoid OR AntivaxBoid, NEVER more than one
- ALL steering behaviors MUST compute `desired_velocity - current_velocity` as the steering force. `desired_velocity = normalize(direction) * max_speed`. NEVER use raw positional differences as forces.
- Alignment desired velocity = `normalize(avg_neighbor_vel) * max_speed`. NEVER use raw averaged velocities.
- Separation = ALL boids. Alignment + Cohesion = SAME-SWARM ONLY.
- Do NOT modify existing component struct fields that are in use — only ADD new fields
- All new parameters go in SimConfig with defaults matching config.ini
- Build and test after EACH change: `cmake --build build && cd build && ctest --output-on-failure`
- Update the relevant module's changelog.md
- Commit with descriptive message before finishing
- Do NOT add Raylib includes outside src/render/
- Do NOT add FLECS includes in src/render/
- All FLECS singleton types MUST be default-constructible (add `T() = default;` + member initializers)
- The render module receives data ONLY through `RenderState` — no direct FLECS access
- If all tasks checked, output RALPH_COMPLETE
